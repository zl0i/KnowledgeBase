## Чистая архитектура

Парадигмы программирования:

1. Структурное программирование

   ​	*Накладывает ограничение на прямую передачу управления (goto)*

2. Объектно-ориентированное программирование

   ​	*Накладывает ограничение на косвенную передачу управления (указатели на функции)*

3. Функциональное программирование 

   ​	*Накладывает ограничение на присваивание (оператор присваивания)*

SOLID принципы:

1. SRP (Single Responsibility Principle) - принцип единственной ответственности 

   - Модуль (класс) должен иметь одну и только одну причину для изменения
   - Модуль (класс) должен отвечать за одного и только за одного пользователя или заинтересованное лицо
   - Модуль (класс) должен отвечать за одного и только за одного актора

2. OCP (Open-Closed Principle) - принципе открытости/закрытости

   - Программные сущности должны быть открыты для расширения и закрыты для изменения

3. LSP (Liskov Substitution Principle) - принцип подстановки Барбары-Лисков

   - Сущности в программе можно заменить их наследниками без изменения свойств программы
   - Наследующий класс должен дополнять, а не замещать поведение базового класс

4. ISP (Interface Segregation Principle) - принцип разделения интерфейсов

   - Программные сущности не должны зависеть от методов, которые они не используют

5. DIP (Dependency Inversion Principle) - принцип инверсии зависимостей

   - Модули верхних уровней не должны импортировать сущности из модулей нижних уровней. Оба типа модулей должны зависеть от абстракций
   - Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций

Связанность компонентов:

1. REP (Reuse/Release Equivalence Principle) - принципе эквивалентности повторного использования и выпусков

   - Единица повторного использования есть единица выпуска
   - Классы и модули, объединяемые в компонент должны выпускаться вместе
   - Каждому выпуску должна быть присвоена версия

2. CCP (Common Closure Principle) - принципе согласованного изменения

   - Во один компонент должны включаться классы, изменяющиеся по одним причинам и в одно время. В разные компоненты должны включаться классы, изменяющиеся в разное время по разным причинам

3. CRP (Common Reuse Principle) - принципе совместного повторного использования

   - Не вынуждайте пользователей компоненты зависеть от того, чего им не требуется
   - Сущности не имеющие тесной связи, не должны включаться в один компонент

Сочетаемость компонентов:

1. Принцип ацикличности зависимостей

   - Циклы в графе зависимостей компонентов недопустимы
   - Циклы можно устранить, использую принципе инверсии зависимостей

2. Принцип устойчивых зависимостей

   - Зависимости должны быть направлены в сторону устойчивости
   - Устойчивость 
$$
I = Fout/Fin+Fout
$$

где, *Fout* - количество исходящих зависимостей,
*Fin* - количество входящих зависимостей,
*I* - устойчивость (0 - максимальная устойчивость, 1 - максимальная неустойчивость )


3. Принцип устойчивости абстракций

   - Устойчивость компоненты пропорциональна его абстрактности
   - Абстрактность
$$
A = Na / Nc
$$

где *Na* - число классов в компоненте,
*Nc* - число абстрактных классов и интерфейсов в компоненте,
*A* - абстрактность (0 - полное отсутствие абстрактности, 1 - полная абстрактность) 

Главная последовательность:

![](https://habrastorage.org/webt/cy/lz/pc/cylzpcfipympkztstfztdmycruy.jpeg)

Расстояние до главной последовательности:	
$$
D = |A+I-1|
$$

где *A* - абстрактность,
*I* - устойчивость,
*D* - расстояние (0 - компонент находится на главной последовательности, 1 - компонент находится на максимальном удалении)

Самыми желательными позициями для компоненты являются конечные точки главной последовательности.